## 也叫 二叉排序树，二叉查找树

### 树的性质：

1. 左子树的节点值，均小于根节点值。
2. 2.右子树的节点值，均大于跟节点值。
3. 中序遍历可以让节点有序

### (1) 查找代价：

任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。

当树中每个结点左右子树高度大致相同时，树高为 logN。则平均查找长度与 logN 成正比，查找的平均时间复杂度在 O(logN)数量级上。

当先后插入的关键字有序时，BST `退化`成单支树结构。此时树高 n。平均查找长度为(n+1)/2，查找的平均时间复杂度在 O(N)数量级上。

### (2) 插入代价：

新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。

### (3) 删除代价：

当删除一个结点 P，首先需要定位到这个结点 P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为 O(1)。如果被删除结点的左、右子树均存在，只需要将当 P 的左孩子的右孩子的右孩子的…的右叶子结点与 P 互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过 O(logN)。

## BST 效率总结 :

- 查找最好时间复杂度 O(logN)，最坏时间复杂度 O(N)。
- 插入删除操作算法简单，时间复杂度与查找差不多。

平衡二叉树 AVL：
拥有二叉搜索树的全部特点+左右子树的高度差不能大于 1

平衡二叉树为了解决二叉搜索树，可能退化成一个近似链表的东西

## 红黑树

插入、删除操作会频繁改动树结构，使性能大打折扣。为了解决这个问题，引入的红黑树

> BST 的创建、插入、删除和查找操作
