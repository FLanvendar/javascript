1，插件的需求：
写代码时，我们为了省事，可以将经常复用的代码抽象出来，写到一个单独的文件中，方便以后再次使用。

2，插件封装的条件：
  1），插件自身的作用域与用户当前的作用于相互独立，也就是插件内部的似有变量不能影响使用者的环境变量
  2），插件需要具备默认设置参数；
  3），插件除了已实现的基本功能外，还需提供部分api。使用者可以通过该api修改插件的默认参数，从而实现用户自定义插件效果。
  4），插件支持链式调用
  5），插件需提供监听入口，及针对指定元素进行监听，使得该元素与插件响应达到效果。


根据上述的这些需求如何一步步实现一个插件。

1,插件的外包装(函数包装和全局对象包装，闭包包装)：
  a),函数包装：
  比如需要的功能时加减乘除操作。那么最最简单的就是：
      function add(n1,n2){
         return n1 + n2;
      }
      function sub(n1,n2){
         return n1 - n2;
      }
      function mul(n1,n2){
         return n1 * n2;
      }
      function div(n1,n2){
         return n1 / n2;
      }
  这样，需要的功能就写完了。这样写，如果只有一个人在一个地方用，那么就基本可以了。但是，如果是多人团队，如果另一个人不知道不知道你是否写了add放嘎，这时他也定义了同样的add方法。那么两人之间就会产生命名冲突，也就是常说的全局污染。
   b) 解决全局污染（用全局对象包装）：
     这个也蛮简单，把函数作为对象的方法就好了。
     比如：
     var plugin = {
        add:function add(n1,n2) {
            return n1+n2;
        },
        sub:function (n1,n2) {
            return n1-n2;
        },
        mul:function (n1,n2) {
            return n1*n2;
        },
        div:function (n1,n2) {
            return n1/n2;
        }
    }
    用上面的方式，约定好插件名为plugin。让团队遵循命名规则，在一定程度上解决了全局污染问题。但也有可能，别人在接手你的项目时，不知道此全局变量已经定义，而后他又定义一次并赋值，这是前面所写的对象就会被覆盖掉。
    所以，更稳妥的办法是：
        if(!plugin){
	  var plugin = {

          }
	}
      这样就不存在命名冲突了。
    c)利用闭包包装
      前面的做法是在全局域里面的。而从性能方面来说，从全局作用域上查找的速度要比在私有作用域上慢很多。所以，最好将插件逻辑写在一个私有作用域中。（私有作用域的实现，最好的方法是闭包） 将插件的所有功能写在一个立即执行函数中：
      ;(function(global, undefined) {
	 var plugin = {
         ...
         }
         //最后将插件对象暴露给全局对象
         !('plugin' in global） && global.plugin = plugin;
       })(window)
     在最后，把window对象当作参数传入，避免了函数执行时到外部查找。插件的用途不一定都用在浏览器上，也可能用在非浏览器端。所以还可以这么做，就是不传参，直接取当前的全局this对象做顶级对象用。
      ;(function(global, undefined) {
         var _global; 
	 var plugin = {
         ...
         }
         //最后将插件对象暴露给全局对象
         _global = (function(){return this || (0, eval)('this');}());
         !('plugin' in _global) && (_global.plugin = plugin);
       })();
     至此，插件的基础结构已算比较完整




